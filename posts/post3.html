<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patrones ArquitectÃ³nicos Modernos | ArquiBlog</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="../index.html" class="logo">
                <span class="logo-icon">â–²</span>
                <span class="logo-text">ArquiBlog</span>
            </a>
            <div class="nav-links">
                <a href="../index.html" class="nav-link">Inicio</a>
                <a href="post1.html" class="nav-link active">Posts</a>
                <a href="../index.html#about" class="nav-link">Acerca de</a>
            </div>
        </div>
    </nav>

    <main class="main-content">
        <article class="post-page">
            <header class="post-header">
                <span class="post-tag">Patrones</span>
                <h1>Patrones ArquitectÃ³nicos Modernos</h1>
                <div class="post-meta">
                    <span>ğŸ“– 18 min lectura</span> Â· <span>Post 3 de 3</span>
                </div>
            </header>

            <div class="post-body">
                <h2>DefiniciÃ³n de PatrÃ³n ArquitectÃ³nico</h2>
                <p>
                    Un <strong>patrÃ³n arquitectÃ³nico</strong> es una soluciÃ³n probada y reutilizable para
                    problemas recurrentes en el diseÃ±o de software a nivel de arquitectura. A diferencia
                    de los estilos arquitectÃ³nicos (que son mÃ¡s abstractos), los patrones proporcionan
                    guÃ­as mÃ¡s especÃ­ficas sobre cÃ³mo estructurar y organizar el cÃ³digo.
                </p>

                <blockquote>
                    <p>
                        "La arquitectura es sobre las decisiones importantes, y las decisiones importantes
                        son aquellas que son difÃ­ciles de cambiar."
                        â€” Martin Fowler
                    </p>
                </blockquote>

                <p>
                    En este artÃ­culo exploraremos tres patrones arquitectÃ³nicos que han ganado gran
                    relevancia en el desarrollo de software moderno: <strong>Clean Architecture</strong>,
                    <strong>Arquitectura Hexagonal</strong> y <strong>CQRS</strong>.
                </p>

                <h2>Clean Architecture</h2>
                <p>
                    <strong>Clean Architecture</strong>, propuesta por Robert C. Martin (Uncle Bob), es un
                    patrÃ³n que enfatiza la separaciÃ³n de responsabilidades y la independencia del negocio
                    respecto a frameworks, bases de datos y otros detalles de implementaciÃ³n.
                </p>

                <h3>Capas de Clean Architecture</h3>
                <p>
                    El patrÃ³n se organiza en capas concÃ©ntricas, donde las dependencias siempre apuntan
                    hacia el interior (hacia el negocio):
                </p>

                <div class="diagram-box">
                    <div class="diagram-title">Clean Architecture - Capas ConcÃ©ntricas</div>
                    <pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRAMEWORKS & DRIVERS                      â”‚
â”‚         (Web, UI, DB, Dispositivos, APIs Externas)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚               INTERFACE ADAPTERS                       â”‚  â”‚
â”‚  â”‚      (Controllers, Gateways, Presenters, ViewModels)  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚              APPLICATION BUSINESS               â”‚  â”‚  â”‚
â”‚  â”‚  â”‚            (Use Cases / Interactors)            â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚          ENTERPRISE BUSINESS              â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚      (Entities / Domain Objects)          â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚                                           â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚    Reglas de negocio mÃ¡s importantes      â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â† â† â† DIRECCIÃ“N DE LAS DEPENDENCIAS â† â† â†
                    (hacia el centro)
                    </pre>
                </div>

                <h4>1. Entities (Entidades)</h4>
                <p>
                    El nÃºcleo mÃ¡s interno. Contiene las <strong>reglas de negocio empresariales</strong>
                    que son las mÃ¡s crÃ­ticas y menos propensas a cambiar. Son independientes de todo.
                </p>

                <h4>2. Use Cases (Casos de Uso)</h4>
                <p>
                    Contiene la <strong>lÃ³gica de aplicaciÃ³n especÃ­fica</strong>. Define quÃ© hace el
                    sistema y orquesta el flujo de datos entre entidades.
                </p>

                <h4>3. Interface Adapters (Adaptadores)</h4>
                <p>
                    Convierte datos entre el formato de los casos de uso y el formato externo
                    (bases de datos, APIs, UI). Incluye Controllers, Presenters y Gateways.
                </p>

                <h4>4. Frameworks & Drivers</h4>
                <p>
                    La capa mÃ¡s externa. Contiene detalles como el framework web, la base de datos,
                    y otras herramientas externas. Es la capa mÃ¡s volÃ¡til.
                </p>

                <h3>PropÃ³sito</h3>
                <ul>
                    <li><strong>Independencia de frameworks:</strong> El negocio no depende de ningÃºn framework</li>
                    <li><strong>Testabilidad:</strong> Las reglas de negocio se pueden probar sin UI, DB, o servicios externos</li>
                    <li><strong>Independencia de UI:</strong> La UI puede cambiar sin afectar el resto del sistema</li>
                    <li><strong>Independencia de base de datos:</strong> Puedes cambiar de Oracle a MongoDB sin tocar el negocio</li>
                </ul>

                <h2>Arquitectura Hexagonal (Puertos y Adaptadores)</h2>
                <p>
                    La <strong>Arquitectura Hexagonal</strong>, propuesta por Alistair Cockburn, tambiÃ©n
                    conocida como "Puertos y Adaptadores", busca aislar el nÃºcleo de la aplicaciÃ³n de
                    las influencias externas mediante interfaces bien definidas.
                </p>

                <div class="diagram-box">
                    <div class="diagram-title">Arquitectura Hexagonal</div>
                    <pre>
                         ADAPTADORES PRIMARIOS
                        (Driving / Entrada)
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   REST    â”‚    CLI     â”‚
                    â”‚   API     â”‚   Tests    â”‚
                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                    â”‚       PUERTOS          â”‚
                    â”‚      (Interfaces)      â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚                 â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚         â”‚  â”‚   DOMINIO /     â”‚   â”‚         â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”     â”‚  â”‚   APLICACIÃ“N    â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”
    â”‚ Adapter â”‚â—„â”€â”€â”€â”€â”¤  â”‚                 â”‚   â”œâ”€â”€â–ºâ”‚ Adapter â”‚
    â”‚   DB    â”‚     â”‚  â”‚  (Core Logic)   â”‚   â”‚   â”‚  Email  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚                 â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                    â”‚       PUERTOS          â”‚
                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                    â”‚ Database â”‚  External   â”‚
                    â”‚          â”‚   Services  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         ADAPTADORES SECUNDARIOS
                          (Driven / Salida)
                    </pre>
                </div>

                <h3>Conceptos Clave</h3>

                <h4>Puertos (Ports)</h4>
                <p>
                    Son <strong>interfaces</strong> que definen cÃ³mo el mundo exterior interactÃºa con
                    la aplicaciÃ³n (puertos primarios) y cÃ³mo la aplicaciÃ³n interactÃºa con servicios
                    externos (puertos secundarios).
                </p>

                <h4>Adaptadores (Adapters)</h4>
                <p>
                    Son <strong>implementaciones concretas</strong> de los puertos. Traducen las
                    solicitudes externas al formato que entiende la aplicaciÃ³n y viceversa.
                </p>

                <div class="info-box highlight">
                    <h4>Diferencia entre Puertos Primarios y Secundarios</h4>
                    <ul>
                        <li><strong>Primarios (Driving):</strong> QuiÃ©n llama a la aplicaciÃ³n (UI, API, Tests)</li>
                        <li><strong>Secundarios (Driven):</strong> A quiÃ©n llama la aplicaciÃ³n (DB, Email, APIs externas)</li>
                    </ul>
                </div>

                <h3>Ejemplo PrÃ¡ctico</h3>
                <p>
                    Imagina un sistema de pedidos:
                </p>
                <ul>
                    <li><strong>Puerto primario:</strong> <code>OrderService</code> interface (para crear, listar pedidos)</li>
                    <li><strong>Adaptador primario:</strong> <code>OrderRestController</code> que expone la API REST</li>
                    <li><strong>Puerto secundario:</strong> <code>OrderRepository</code> interface (para persistir)</li>
                    <li><strong>Adaptador secundario:</strong> <code>PostgresOrderRepository</code> implementaciÃ³n</li>
                </ul>

                <h2>PatrÃ³n CQRS (Command Query Responsibility Segregation)</h2>
                <p>
                    <strong>CQRS</strong> es un patrÃ³n que separa las operaciones de lectura (Queries)
                    de las operaciones de escritura (Commands) en modelos diferentes. Propuesto por
                    Greg Young, es especialmente Ãºtil en sistemas con requisitos de lectura y escritura
                    muy diferentes.
                </p>

                <div class="diagram-box">
                    <div class="diagram-title">PatrÃ³n CQRS</div>
                    <pre>
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   CLIENTE   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                  â”‚                  â”‚
            â†“                                     â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   COMMANDS    â”‚                    â”‚    QUERIES    â”‚
    â”‚   (Writes)    â”‚                    â”‚    (Reads)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                    â”‚
            â†“                                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Command     â”‚                    â”‚    Query      â”‚
    â”‚   Handlers    â”‚                    â”‚    Handlers   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                    â”‚
            â†“                                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      sync/         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Write Model  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   â”‚  Read Model   â”‚
    â”‚  (Normalized) â”‚      event         â”‚ (Optimizado   â”‚
    â”‚               â”‚                    â”‚  para queries)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                    â”‚
            â†“                                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Write DB    â”‚                    â”‚   Read DB     â”‚
    â”‚  (PostgreSQL) â”‚                    â”‚   (MongoDB,   â”‚
    â”‚               â”‚                    â”‚    Redis)     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    </pre>
                </div>

                <h3>Conceptos Fundamentales</h3>

                <h4>Commands (Comandos)</h4>
                <p>
                    Representan <strong>intenciones de cambio</strong> en el sistema. Son imperativos
                    que modifican el estado: <code>CreateOrder</code>, <code>UpdateUser</code>,
                    <code>DeleteProduct</code>.
                </p>

                <h4>Queries (Consultas)</h4>
                <p>
                    Representan <strong>solicitudes de datos</strong> sin modificar el estado:
                    <code>GetOrderById</code>, <code>ListActiveUsers</code>, <code>SearchProducts</code>.
                </p>

                <h4>Handlers (Manejadores)</h4>
                <p>
                    Procesan los commands y queries. Cada uno tiene su propio modelo optimizado
                    para su propÃ³sito especÃ­fico.
                </p>

                <div class="info-box">
                    <h4>CuÃ¡ndo usar CQRS</h4>
                    <ul>
                        <li>Sistemas con patrones de lectura/escritura muy diferentes</li>
                        <li>Necesidad de optimizar lecturas independientemente de escrituras</li>
                        <li>Sistemas colaborativos con mÃºltiples vistas de los mismos datos</li>
                        <li>IntegraciÃ³n con Event Sourcing</li>
                    </ul>
                </div>

                <h2>Ventajas y Desventajas de Cada PatrÃ³n</h2>

                <h3>Clean Architecture</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Ventajas</th>
                            <th>Desventajas</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Independencia total del framework</td>
                            <td>Curva de aprendizaje pronunciada</td>
                        </tr>
                        <tr>
                            <td>Altamente testeable</td>
                            <td>MÃ¡s cÃ³digo boilerplate</td>
                        </tr>
                        <tr>
                            <td>Facilita el mantenimiento a largo plazo</td>
                            <td>Puede ser excesivo para proyectos pequeÃ±os</td>
                        </tr>
                        <tr>
                            <td>Clara separaciÃ³n de responsabilidades</td>
                            <td>Requiere disciplina del equipo</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Arquitectura Hexagonal</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Ventajas</th>
                            <th>Desventajas</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>FÃ¡cil de testear con mocks</td>
                            <td>AbstracciÃ³n adicional puede ser confusa</td>
                        </tr>
                        <tr>
                            <td>Flexibilidad para cambiar adaptadores</td>
                            <td>MÃ¡s interfaces que implementar</td>
                        </tr>
                        <tr>
                            <td>Dominio protegido de cambios externos</td>
                            <td>Overhead para aplicaciones simples</td>
                        </tr>
                        <tr>
                            <td>SimetrÃ­a conceptual clara</td>
                            <td>Requiere buenos conocimientos de diseÃ±o</td>
                        </tr>
                    </tbody>
                </table>

                <h3>CQRS</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Ventajas</th>
                            <th>Desventajas</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>OptimizaciÃ³n independiente de reads/writes</td>
                            <td>Complejidad significativamente mayor</td>
                        </tr>
                        <tr>
                            <td>Escalabilidad granular</td>
                            <td>Consistencia eventual puede ser problemÃ¡tica</td>
                        </tr>
                        <tr>
                            <td>Modelos de datos especializados</td>
                            <td>SincronizaciÃ³n entre modelos</td>
                        </tr>
                        <tr>
                            <td>Excelente para sistemas distribuidos</td>
                            <td>No apto para aplicaciones CRUD simples</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Ejemplos de AplicaciÃ³n en Proyectos Modernos</h2>

                <h3>Clean Architecture</h3>
                <div class="info-box">
                    <h4>Caso: AplicaciÃ³n Bancaria</h4>
                    <p>
                        Un banco implementa Clean Architecture para su core banking. Las reglas de
                        negocio (cÃ¡lculo de intereses, validaciÃ³n de transacciones) estÃ¡n en el centro,
                        completamente aisladas. Pueden cambiar de Oracle a PostgreSQL, o de una API
                        REST a GraphQL, sin tocar una lÃ­nea del cÃ³digo de negocio.
                    </p>
                </div>

                <h3>Arquitectura Hexagonal</h3>
                <div class="info-box">
                    <h4>Caso: Sistema de E-commerce</h4>
                    <p>
                        Una plataforma de e-commerce usa Hexagonal para su mÃ³dulo de pagos. El dominio
                        define interfaces para procesadores de pago (Puerto), y tienen adaptadores
                        para Stripe, PayPal y transferencias bancarias. Agregar un nuevo mÃ©todo de
                        pago solo requiere crear un nuevo adaptador.
                    </p>
                </div>

                <h3>CQRS</h3>
                <div class="info-box">
                    <h4>Caso: Red Social</h4>
                    <p>
                        Una red social implementa CQRS para manejar el feed de noticias. Las escrituras
                        (posts, likes, comentarios) van a una base de datos normalizada. Las lecturas
                        del feed se sirven desde vistas materializadas optimizadas en Redis, actualizadas
                        asÃ­ncronamente. Esto permite millones de lecturas por segundo.
                    </p>
                </div>

                <h2>ConclusiÃ³n General: Comparando los Tres Patrones</h2>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspecto</th>
                            <th>Clean Architecture</th>
                            <th>Hexagonal</th>
                            <th>CQRS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Enfoque Principal</strong></td>
                            <td>Independencia de frameworks</td>
                            <td>Aislamiento del dominio</td>
                            <td>SeparaciÃ³n read/write</td>
                        </tr>
                        <tr>
                            <td><strong>Complejidad</strong></td>
                            <td>Media-Alta</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Mejor Para</strong></td>
                            <td>Apps empresariales complejas</td>
                            <td>Sistemas con mÃºltiples interfaces</td>
                            <td>Alto trÃ¡fico, reads â‰  writes</td>
                        </tr>
                        <tr>
                            <td><strong>Curva de Aprendizaje</strong></td>
                            <td>Pronunciada</td>
                            <td>Moderada</td>
                            <td>Pronunciada</td>
                        </tr>
                        <tr>
                            <td><strong>Compatibilidad</strong></td>
                            <td>Se combina bien con Hexagonal</td>
                            <td>Base para Clean Architecture</td>
                            <td>Complementa ambos</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box highlight">
                    <h4>ReflexiÃ³n Final</h4>
                    <p>
                        Estos patrones no son mutuamente excluyentes. De hecho, muchos proyectos exitosos
                        combinan elementos de los tres. Por ejemplo, puedes usar Clean Architecture como
                        base, con la organizaciÃ³n de Puertos y Adaptadores de Hexagonal, y aplicar CQRS
                        en mÃ³dulos especÃ­ficos donde la separaciÃ³n de lecturas y escrituras aporte valor.
                    </p>
                    <p>
                        La clave estÃ¡ en <strong>entender el problema antes de elegir la soluciÃ³n</strong>.
                        No adoptes un patrÃ³n porque estÃ¡ de moda; adÃ³ptalo porque resuelve una necesidad
                        real de tu proyecto.
                    </p>
                </div>

                <p>
                    Con esto concluimos nuestra serie sobre Arquitectura de Software. Desde los
                    fundamentos hasta los patrones mÃ¡s modernos, esperamos que este conocimiento
                    te ayude a diseÃ±ar sistemas mÃ¡s robustos, mantenibles y escalables.
                </p>
            </div>

            <nav class="post-navigation">
                <a href="post2.html" class="nav-card prev">
                    <span class="nav-label">â† Anterior</span>
                    <span class="nav-title">Estilos ArquitectÃ³nicos</span>
                </a>
                <a href="../index.html" class="nav-card next">
                    <span class="nav-label">Volver â†’</span>
                    <span class="nav-title">PÃ¡gina Principal</span>
                </a>
            </nav>
        </article>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <div class="footer-logo">
                <span class="logo-icon">â–²</span>
                <span>ArquiBlog</span>
            </div>
            <p class="footer-text">
                Â© 2024 Blog de Arquitectura de Software.
                Desarrollado con HTML, CSS y JavaScript.
            </p>
        </div>
    </footer>

    <script src="../scripts.js"></script>
</body>
</html>
